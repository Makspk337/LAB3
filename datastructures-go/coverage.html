
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>datastructures: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">datastructures/array.go (76.7%)</option>
				
				<option value="file1">datastructures/cmd/coverage/main.go (0.0%)</option>
				
				<option value="file2">datastructures/doubly_list.go (91.2%)</option>
				
				<option value="file3">datastructures/forward_list.go (87.6%)</option>
				
				<option value="file4">datastructures/hash_table.go (80.7%)</option>
				
				<option value="file5">datastructures/queue.go (86.8%)</option>
				
				<option value="file6">datastructures/stack.go (85.3%)</option>
				
				<option value="file7">datastructures/tree.go (83.5%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package datastructures

import (
        "encoding/binary"
        "fmt"
        "io"
        "strings"
)

type Array struct {
        Name     string
        data     []string
        capacity int
}

func NewArray(name string, initialCapacity ...int) *Array <span class="cov8" title="1">{
        capacity := 8
        if len(initialCapacity) &gt; 0 &amp;&amp; initialCapacity[0] &gt; 0 </span><span class="cov0" title="0">{
                capacity = initialCapacity[0]
        }</span>
        <span class="cov8" title="1">return &amp;Array{
                Name:     name,
                data:     make([]string, 0, capacity),
                capacity: capacity,
        }</span>
}

func (a *Array) ensureCapacity() <span class="cov8" title="1">{
        if len(a.data) &lt; cap(a.data) </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov0" title="0">newCapacity := cap(a.data) * 2
        if newCapacity == 0 </span><span class="cov0" title="0">{
                newCapacity = 1
        }</span>
        <span class="cov0" title="0">newData := make([]string, len(a.data), newCapacity)
        copy(newData, a.data)
        a.data = newData</span>
}

func (a *Array) PushBack(value string) <span class="cov8" title="1">{
        a.ensureCapacity()
        a.data = append(a.data, value)
}</span>

func (a *Array) Insert(index int, value string) error <span class="cov8" title="1">{
        if index &lt; 0 || index &gt; len(a.data) </span><span class="cov8" title="1">{
                return fmt.Errorf("index out of bounds")
        }</span>
        <span class="cov8" title="1">a.ensureCapacity()
        a.data = append(a.data, "")
        copy(a.data[index+1:], a.data[index:])
        a.data[index] = value
        return nil</span>
}

func (a *Array) Get(index int) (string, error) <span class="cov8" title="1">{
        if index &lt; 0 || index &gt;= len(a.data) </span><span class="cov8" title="1">{
                return "", fmt.Errorf("index out of bounds")
        }</span>
        <span class="cov8" title="1">return a.data[index], nil</span>
}

func (a *Array) Remove(index int) error <span class="cov8" title="1">{
        if index &lt; 0 || index &gt;= len(a.data) </span><span class="cov8" title="1">{
                return fmt.Errorf("index out of bounds")
        }</span>
        <span class="cov8" title="1">a.data = append(a.data[:index], a.data[index+1:]...)
        return nil</span>
}

func (a *Array) Replace(index int, value string) error <span class="cov8" title="1">{
        if index &lt; 0 || index &gt;= len(a.data) </span><span class="cov8" title="1">{
                return fmt.Errorf("index out of bounds")
        }</span>
        <span class="cov8" title="1">a.data[index] = value
        return nil</span>
}

func (a *Array) Length() int <span class="cov8" title="1">{
        return len(a.data)
}</span>

func (a *Array) Read() string <span class="cov8" title="1">{
        return strings.Join(a.data, " ")
}</span>

func (a *Array) SerializeBinary(w io.Writer) error <span class="cov8" title="1">{
        length := uint32(len(a.data))
        if err := binary.Write(w, binary.LittleEndian, length); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">for _, s := range a.data </span><span class="cov8" title="1">{
                length := uint32(len(s))
                if err := binary.Write(w, binary.LittleEndian, length); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if _, err := w.Write([]byte(s)); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (a *Array) DeserializeBinary(r io.Reader) error <span class="cov8" title="1">{
        var length uint32
        if err := binary.Read(r, binary.LittleEndian, &amp;length); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        
        <span class="cov8" title="1">a.data = make([]string, 0, length)
        for i := uint32(0); i &lt; length; i++ </span><span class="cov8" title="1">{
                var strLen uint32
                if err := binary.Read(r, binary.LittleEndian, &amp;strLen); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                
                <span class="cov8" title="1">buf := make([]byte, strLen)
                if _, err := io.ReadFull(r, buf); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">a.data = append(a.data, string(buf))</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (a *Array) SerializeText(w io.Writer) error <span class="cov8" title="1">{
        if _, err := fmt.Fprintf(w, "%d\n", len(a.data)); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">for _, s := range a.data </span><span class="cov8" title="1">{
                if _, err := fmt.Fprintf(w, "%s\n", s); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (a *Array) DeserializeText(r io.Reader) error <span class="cov8" title="1">{
        var length int
        if _, err := fmt.Fscanf(r, "%d\n", &amp;length); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        
        <span class="cov8" title="1">a.data = make([]string, 0, length)
        for i := 0; i &lt; length; i++ </span><span class="cov8" title="1">{
                var s string
                if _, err := fmt.Fscanf(r, "%s\n", &amp;s); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">a.data = append(a.data, s)</span>
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "fmt"
        "os"
        "os/exec"
)

func main() <span class="cov0" title="0">{
        fmt.Println("Running tests and generating coverage report...")
        
        cmd := exec.Command("go", "test", "-coverprofile=coverage.out", "./...")
        cmd.Stdout = os.Stdout
        cmd.Stderr = os.Stderr
        
        if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Error running tests: %v\n", err)
                os.Exit(1)
        }</span>
        
        <span class="cov0" title="0">cmd = exec.Command("go", "tool", "cover", "-html=coverage.out", "-o", "coverage.html")
        cmd.Stdout = os.Stdout
        cmd.Stderr = os.Stderr
        
        if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Error generating HTML coverage: %v\n", err)
                os.Exit(1)
        }</span>
        
        <span class="cov0" title="0">fmt.Println("Coverage report generated: coverage.html")
        fmt.Println("Opening coverage report in browser...")
        
        cmd = exec.Command("open", "coverage.html")
        if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Error opening coverage report: %v\n", err)
                fmt.Println("You can open it manually by running: open coverage.html")
        }</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package datastructures

import (
        "encoding/binary"
        "fmt"
        "io"
        "strings"
)

type doublyListNode struct {
        value string
        prev  *doublyListNode
        next  *doublyListNode
}

type DoublyList struct {
        Name string
        head *doublyListNode
        tail *doublyListNode
}

func NewDoublyList(name string) *DoublyList <span class="cov8" title="1">{
        return &amp;DoublyList{Name: name}
}</span>

func (dl *DoublyList) clear() <span class="cov8" title="1">{
        dl.head = nil
        dl.tail = nil
}</span>

func (dl *DoublyList) PushHead(value string) <span class="cov8" title="1">{
        node := &amp;doublyListNode{value: value}
        node.next = dl.head
        if dl.head != nil </span><span class="cov8" title="1">{
                dl.head.prev = node
        }</span> else<span class="cov8" title="1"> {
                dl.tail = node
        }</span>
        <span class="cov8" title="1">dl.head = node</span>
}

func (dl *DoublyList) PushTail(value string) <span class="cov8" title="1">{
        node := &amp;doublyListNode{value: value}
        node.prev = dl.tail
        if dl.tail != nil </span><span class="cov8" title="1">{
                dl.tail.next = node
        }</span> else<span class="cov8" title="1"> {
                dl.head = node
        }</span>
        <span class="cov8" title="1">dl.tail = node</span>
}

func (dl *DoublyList) PushBefore(before, value string) <span class="cov8" title="1">{
        current := dl.head
        for current != nil </span><span class="cov8" title="1">{
                if current.value == before </span><span class="cov8" title="1">{
                        if current == dl.head </span><span class="cov8" title="1">{
                                dl.PushHead(value)
                                return
                        }</span>
                        <span class="cov8" title="1">node := &amp;doublyListNode{value: value}
                        node.prev = current.prev
                        node.next = current
                        current.prev.next = node
                        current.prev = node
                        return</span>
                }
                <span class="cov8" title="1">current = current.next</span>
        }
}

func (dl *DoublyList) PushAfter(after, value string) <span class="cov8" title="1">{
        current := dl.head
        for current != nil </span><span class="cov8" title="1">{
                if current.value == after </span><span class="cov8" title="1">{
                        if current == dl.tail </span><span class="cov8" title="1">{
                                dl.PushTail(value)
                                return
                        }</span>
                        <span class="cov8" title="1">node := &amp;doublyListNode{value: value}
                        node.next = current.next
                        node.prev = current
                        current.next.prev = node
                        current.next = node
                        return</span>
                }
                <span class="cov8" title="1">current = current.next</span>
        }
}

func (dl *DoublyList) DeleteHead() <span class="cov8" title="1">{
        if dl.head == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">dl.head = dl.head.next
        if dl.head != nil </span><span class="cov8" title="1">{
                dl.head.prev = nil
        }</span> else<span class="cov8" title="1"> {
                dl.tail = nil
        }</span>
}

func (dl *DoublyList) DeleteTail() <span class="cov8" title="1">{
        if dl.tail == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">dl.tail = dl.tail.prev
        if dl.tail != nil </span><span class="cov8" title="1">{
                dl.tail.next = nil
        }</span> else<span class="cov8" title="1"> {
                dl.head = nil
        }</span>
}

func (dl *DoublyList) DeleteBefore(value string) <span class="cov8" title="1">{
        current := dl.head
        for current != nil </span><span class="cov8" title="1">{
                if current.value == value </span><span class="cov8" title="1">{
                        target := current.prev
                        if target == nil </span><span class="cov8" title="1">{
                                return
                        }</span>
                        <span class="cov8" title="1">if target == dl.head </span><span class="cov0" title="0">{
                                dl.DeleteHead()
                                return
                        }</span>
                        <span class="cov8" title="1">target.prev.next = current
                        current.prev = target.prev
                        return</span>
                }
                <span class="cov8" title="1">current = current.next</span>
        }
}

func (dl *DoublyList) DeleteAfter(value string) <span class="cov8" title="1">{
        current := dl.head
        for current != nil </span><span class="cov8" title="1">{
                if current.value == value </span><span class="cov8" title="1">{
                        target := current.next
                        if target == nil </span><span class="cov8" title="1">{
                                return
                        }</span>
                        <span class="cov8" title="1">if target == dl.tail </span><span class="cov0" title="0">{
                                dl.DeleteTail()
                                return
                        }</span>
                        <span class="cov8" title="1">current.next = target.next
                        target.next.prev = current
                        return</span>
                }
                <span class="cov8" title="1">current = current.next</span>
        }
}

func (dl *DoublyList) DeleteValue(value string) <span class="cov8" title="1">{
        current := dl.head
        for current != nil </span><span class="cov8" title="1">{
                if current.value == value </span><span class="cov8" title="1">{
                        if current == dl.head </span><span class="cov8" title="1">{
                                dl.DeleteHead()
                                return
                        }</span>
                        <span class="cov8" title="1">if current == dl.tail </span><span class="cov8" title="1">{
                                dl.DeleteTail()
                                return
                        }</span>
                        <span class="cov8" title="1">current.prev.next = current.next
                        current.next.prev = current.prev
                        return</span>
                }
                <span class="cov8" title="1">current = current.next</span>
        }
}

func (dl *DoublyList) Find(value string) bool <span class="cov8" title="1">{
        current := dl.head
        for current != nil </span><span class="cov8" title="1">{
                if current.value == value </span><span class="cov8" title="1">{
                        return true
                }</span>
                <span class="cov8" title="1">current = current.next</span>
        }
        <span class="cov8" title="1">return false</span>
}

func (dl *DoublyList) Read() string <span class="cov8" title="1">{
        var values []string
        current := dl.head
        for current != nil </span><span class="cov8" title="1">{
                values = append(values, current.value)
                current = current.next
        }</span>
        <span class="cov8" title="1">return strings.Join(values, " ")</span>
}

func (dl *DoublyList) ReadReverse() string <span class="cov8" title="1">{
        var values []string
        current := dl.tail
        for current != nil </span><span class="cov8" title="1">{
                values = append(values, current.value)
                current = current.prev
        }</span>
        <span class="cov8" title="1">return strings.Join(values, " ")</span>
}

func (dl *DoublyList) SerializeBinary(w io.Writer) error <span class="cov8" title="1">{
        var values []string
        current := dl.head
        for current != nil </span><span class="cov8" title="1">{
                values = append(values, current.value)
                current = current.next
        }</span>
        
        <span class="cov8" title="1">length := uint32(len(values))
        if err := binary.Write(w, binary.LittleEndian, length); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        
        <span class="cov8" title="1">for _, v := range values </span><span class="cov8" title="1">{
                strLen := uint32(len(v))
                if err := binary.Write(w, binary.LittleEndian, strLen); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if _, err := w.Write([]byte(v)); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (dl *DoublyList) DeserializeBinary(r io.Reader) error <span class="cov8" title="1">{
        dl.clear()
        
        var length uint32
        if err := binary.Read(r, binary.LittleEndian, &amp;length); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        
        <span class="cov8" title="1">for i := uint32(0); i &lt; length; i++ </span><span class="cov8" title="1">{
                var strLen uint32
                if err := binary.Read(r, binary.LittleEndian, &amp;strLen); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                
                <span class="cov8" title="1">buf := make([]byte, strLen)
                if _, err := io.ReadFull(r, buf); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">dl.PushTail(string(buf))</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (dl *DoublyList) SerializeText(w io.Writer) error <span class="cov8" title="1">{
        var values []string
        current := dl.head
        for current != nil </span><span class="cov8" title="1">{
                values = append(values, current.value)
                current = current.next
        }</span>
        
        <span class="cov8" title="1">if _, err := fmt.Fprintf(w, "%d\n", len(values)); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">for _, v := range values </span><span class="cov8" title="1">{
                if _, err := fmt.Fprintf(w, "%s\n", v); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (dl *DoublyList) DeserializeText(r io.Reader) error <span class="cov8" title="1">{
        dl.clear()
        
        var length int
        if _, err := fmt.Fscanf(r, "%d\n", &amp;length); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        
        <span class="cov8" title="1">for i := 0; i &lt; length; i++ </span><span class="cov8" title="1">{
                var s string
                if _, err := fmt.Fscanf(r, "%s\n", &amp;s); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">dl.PushTail(s)</span>
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package datastructures

import (
        "encoding/binary"
        "fmt"
        "io"
        "strings"
)

type forwardListNode struct {
        value string
        next  *forwardListNode
}

type ForwardList struct {
        Name string
        head *forwardListNode
}

func NewForwardList(name string) *ForwardList <span class="cov8" title="1">{
        return &amp;ForwardList{Name: name}
}</span>

func (fl *ForwardList) clear() <span class="cov8" title="1">{
        fl.head = nil
}</span>

func (fl *ForwardList) PushHead(value string) <span class="cov8" title="1">{
        node := &amp;forwardListNode{value: value}
        node.next = fl.head
        fl.head = node
}</span>

func (fl *ForwardList) PushTail(value string) <span class="cov8" title="1">{
        node := &amp;forwardListNode{value: value}
        if fl.head == nil </span><span class="cov8" title="1">{
                fl.head = node
                return
        }</span>
        
        <span class="cov8" title="1">current := fl.head
        for current.next != nil </span><span class="cov8" title="1">{
                current = current.next
        }</span>
        <span class="cov8" title="1">current.next = node</span>
}

func (fl *ForwardList) PushBefore(before, value string) <span class="cov8" title="1">{
        if fl.head == nil </span><span class="cov0" title="0">{
                return
        }</span>
        
        <span class="cov8" title="1">if fl.head.value == before </span><span class="cov8" title="1">{
                fl.PushHead(value)
                return
        }</span>
        
        <span class="cov8" title="1">prev := fl.head
        current := fl.head.next
        for current != nil </span><span class="cov8" title="1">{
                if current.value == before </span><span class="cov8" title="1">{
                        node := &amp;forwardListNode{value: value}
                        prev.next = node
                        node.next = current
                        return
                }</span>
                <span class="cov0" title="0">prev = current
                current = current.next</span>
        }
}

func (fl *ForwardList) PushAfter(after, value string) <span class="cov8" title="1">{
        current := fl.head
        for current != nil </span><span class="cov8" title="1">{
                if current.value == after </span><span class="cov8" title="1">{
                        node := &amp;forwardListNode{value: value}
                        node.next = current.next
                        current.next = node
                        return
                }</span>
                <span class="cov8" title="1">current = current.next</span>
        }
}

func (fl *ForwardList) DeleteHead() <span class="cov8" title="1">{
        if fl.head == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">fl.head = fl.head.next</span>
}

func (fl *ForwardList) DeleteTail() <span class="cov8" title="1">{
        if fl.head == nil </span><span class="cov8" title="1">{
                return
        }</span>
        
        <span class="cov8" title="1">if fl.head.next == nil </span><span class="cov8" title="1">{
                fl.head = nil
                return
        }</span>
        
        <span class="cov8" title="1">prev := fl.head
        current := fl.head.next
        for current.next != nil </span><span class="cov8" title="1">{
                prev = current
                current = current.next
        }</span>
        <span class="cov8" title="1">prev.next = nil</span>
}

func (fl *ForwardList) DeleteBefore(value string) <span class="cov8" title="1">{
        if fl.head == nil || fl.head.next == nil </span><span class="cov0" title="0">{
                return
        }</span>
        
        <span class="cov8" title="1">if fl.head.next.value == value </span><span class="cov0" title="0">{
                fl.DeleteHead()
                return
        }</span>
        
        <span class="cov8" title="1">prevPrev := fl.head
        prev := fl.head.next
        current := prev.next
        
        for current != nil </span><span class="cov8" title="1">{
                if current.value == value </span><span class="cov8" title="1">{
                        prevPrev.next = current
                        return
                }</span>
                <span class="cov8" title="1">prevPrev = prev
                prev = current
                current = current.next</span>
        }
}

func (fl *ForwardList) DeleteAfter(value string) <span class="cov8" title="1">{
        current := fl.head
        for current != nil &amp;&amp; current.next != nil </span><span class="cov8" title="1">{
                if current.value == value </span><span class="cov8" title="1">{
                        current.next = current.next.next
                        return
                }</span>
                <span class="cov8" title="1">current = current.next</span>
        }
}

func (fl *ForwardList) DeleteValue(value string) <span class="cov8" title="1">{
        if fl.head == nil </span><span class="cov0" title="0">{
                return
        }</span>
        
        <span class="cov8" title="1">if fl.head.value == value </span><span class="cov8" title="1">{
                fl.DeleteHead()
                return
        }</span>
        
        <span class="cov8" title="1">prev := fl.head
        current := fl.head.next
        
        for current != nil </span><span class="cov8" title="1">{
                if current.value == value </span><span class="cov8" title="1">{
                        prev.next = current.next
                        return
                }</span>
                <span class="cov0" title="0">prev = current
                current = current.next</span>
        }
}

func (fl *ForwardList) Find(value string) bool <span class="cov8" title="1">{
        current := fl.head
        for current != nil </span><span class="cov8" title="1">{
                if current.value == value </span><span class="cov8" title="1">{
                        return true
                }</span>
                <span class="cov8" title="1">current = current.next</span>
        }
        <span class="cov8" title="1">return false</span>
}

func (fl *ForwardList) Read() string <span class="cov8" title="1">{
        var values []string
        current := fl.head
        for current != nil </span><span class="cov8" title="1">{
                values = append(values, current.value)
                current = current.next
        }</span>
        <span class="cov8" title="1">return strings.Join(values, " ")</span>
}

func (fl *ForwardList) ReadReverse() string <span class="cov8" title="1">{
        var values []string
        current := fl.head
        for current != nil </span><span class="cov8" title="1">{
                values = append(values, current.value)
                current = current.next
        }</span>
        
        <span class="cov8" title="1">for i, j := 0, len(values)-1; i &lt; j; i, j = i+1, j-1 </span><span class="cov8" title="1">{
                values[i], values[j] = values[j], values[i]
        }</span>
        <span class="cov8" title="1">return strings.Join(values, " ")</span>
}

func (fl *ForwardList) SerializeBinary(w io.Writer) error <span class="cov8" title="1">{
        var values []string
        current := fl.head
        for current != nil </span><span class="cov8" title="1">{
                values = append(values, current.value)
                current = current.next
        }</span>
        
        <span class="cov8" title="1">length := uint32(len(values))
        if err := binary.Write(w, binary.LittleEndian, length); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        
        <span class="cov8" title="1">for _, v := range values </span><span class="cov8" title="1">{
                strLen := uint32(len(v))
                if err := binary.Write(w, binary.LittleEndian, strLen); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if _, err := w.Write([]byte(v)); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (fl *ForwardList) DeserializeBinary(r io.Reader) error <span class="cov8" title="1">{
        fl.clear()
        
        var length uint32
        if err := binary.Read(r, binary.LittleEndian, &amp;length); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        
        <span class="cov8" title="1">for i := uint32(0); i &lt; length; i++ </span><span class="cov8" title="1">{
                var strLen uint32
                if err := binary.Read(r, binary.LittleEndian, &amp;strLen); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                
                <span class="cov8" title="1">buf := make([]byte, strLen)
                if _, err := io.ReadFull(r, buf); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">fl.PushTail(string(buf))</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (fl *ForwardList) SerializeText(w io.Writer) error <span class="cov8" title="1">{
        var values []string
        current := fl.head
        for current != nil </span><span class="cov8" title="1">{
                values = append(values, current.value)
                current = current.next
        }</span>
        
        <span class="cov8" title="1">if _, err := fmt.Fprintf(w, "%d\n", len(values)); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">for _, v := range values </span><span class="cov8" title="1">{
                if _, err := fmt.Fprintf(w, "%s\n", v); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (fl *ForwardList) DeserializeText(r io.Reader) error <span class="cov8" title="1">{
        fl.clear()
        
        var length int
        if _, err := fmt.Fscanf(r, "%d\n", &amp;length); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        
        <span class="cov8" title="1">for i := 0; i &lt; length; i++ </span><span class="cov8" title="1">{
                var s string
                if _, err := fmt.Fscanf(r, "%s\n", &amp;s); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">fl.PushTail(s)</span>
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package datastructures

import (
        "encoding/binary"
        "fmt"
        "io"
)

type SlotState uint8

const (
        Empty SlotState = iota
        Filled
        Deleted
)

const maxLoadFactor = 0.6

type HashTable struct {
        keys    []int
        values  []int
        states  []SlotState
        capacity int
        count    int
}

func NewHashTable(capacity ...int) *HashTable <span class="cov8" title="1">{
        cap := 8
        if len(capacity) &gt; 0 &amp;&amp; capacity[0] &gt; 0 </span><span class="cov8" title="1">{
                cap = capacity[0]
        }</span>
        
        <span class="cov8" title="1">ht := &amp;HashTable{
                capacity: nextPow2(cap),
        }
        ht.keys = make([]int, ht.capacity)
        ht.values = make([]int, ht.capacity)
        ht.states = make([]SlotState, ht.capacity)
        
        for i := range ht.states </span><span class="cov8" title="1">{
                ht.states[i] = Empty
        }</span>
        
        <span class="cov8" title="1">return ht</span>
}

func nextPow2(n int) int <span class="cov8" title="1">{
        p := 1
        for p &lt; n </span><span class="cov8" title="1">{
                p &lt;&lt;= 1
        }</span>
        <span class="cov8" title="1">return p</span>
}

func (ht *HashTable) hash(key int) int <span class="cov8" title="1">{
        x := uint32(key)
        x *= 2654435761
        return int(x &amp; uint32(ht.capacity-1))
}</span>

func (ht *HashTable) rehash(newCapacity int) <span class="cov8" title="1">{
        newCapacity = nextPow2(newCapacity)
        if newCapacity &lt; 2 </span><span class="cov0" title="0">{
                newCapacity = 2
        }</span>
        
        <span class="cov8" title="1">oldKeys := ht.keys
        oldValues := ht.values
        oldStates := ht.states
        oldCap := ht.capacity
        
        ht.keys = make([]int, newCapacity)
        ht.values = make([]int, newCapacity)
        ht.states = make([]SlotState, newCapacity)
        ht.capacity = newCapacity
        ht.count = 0
        
        for i := range ht.states </span><span class="cov8" title="1">{
                ht.states[i] = Empty
        }</span>
        
        <span class="cov8" title="1">for i := 0; i &lt; oldCap; i++ </span><span class="cov8" title="1">{
                if oldStates[i] == Filled </span><span class="cov8" title="1">{
                        ht.Insert(oldKeys[i], oldValues[i])
                }</span>
        }
}

func (ht *HashTable) Insert(key, value int) <span class="cov8" title="1">{
        if float64(ht.count+1)/float64(ht.capacity) &gt; maxLoadFactor </span><span class="cov8" title="1">{
                ht.rehash(ht.capacity * 2)
        }</span>
        
        <span class="cov8" title="1">idx := ht.hash(key)
        firstDeleted := -1
        
        for probe := 0; probe &lt; ht.capacity; probe++ </span><span class="cov8" title="1">{
                pos := (idx + probe) &amp; (ht.capacity - 1)
                
                if ht.states[pos] == Filled &amp;&amp; ht.keys[pos] == key </span><span class="cov8" title="1">{
                        ht.values[pos] = value
                        return
                }</span>
                
                <span class="cov8" title="1">if ht.states[pos] == Deleted &amp;&amp; firstDeleted == -1 </span><span class="cov0" title="0">{
                        firstDeleted = pos
                }</span>
                
                <span class="cov8" title="1">if ht.states[pos] == Empty </span><span class="cov8" title="1">{
                        target := pos
                        if firstDeleted != -1 </span><span class="cov0" title="0">{
                                target = firstDeleted
                        }</span>
                        <span class="cov8" title="1">ht.keys[target] = key
                        ht.values[target] = value
                        ht.states[target] = Filled
                        ht.count++
                        return</span>
                }
        }
        
        <span class="cov0" title="0">ht.rehash(ht.capacity * 2)
        ht.Insert(key, value)</span>
}

func (ht *HashTable) Contains(key int) bool <span class="cov8" title="1">{
        return ht.Get(key) != -1
}</span>

func (ht *HashTable) Get(key int) int <span class="cov8" title="1">{
        idx := ht.hash(key)
        
        for probe := 0; probe &lt; ht.capacity; probe++ </span><span class="cov8" title="1">{
                pos := (idx + probe) &amp; (ht.capacity - 1)
                
                if ht.states[pos] == Empty </span><span class="cov8" title="1">{
                        return -1
                }</span>
                
                <span class="cov8" title="1">if ht.states[pos] == Filled &amp;&amp; ht.keys[pos] == key </span><span class="cov8" title="1">{
                        return ht.values[pos]
                }</span>
        }
        
        <span class="cov0" title="0">return -1</span>
}

func (ht *HashTable) Remove(key int) <span class="cov8" title="1">{
        idx := ht.hash(key)
        
        for probe := 0; probe &lt; ht.capacity; probe++ </span><span class="cov8" title="1">{
                pos := (idx + probe) &amp; (ht.capacity - 1)
                
                if ht.states[pos] == Empty </span><span class="cov8" title="1">{
                        return
                }</span>
                
                <span class="cov8" title="1">if ht.states[pos] == Filled &amp;&amp; ht.keys[pos] == key </span><span class="cov8" title="1">{
                        ht.states[pos] = Deleted
                        ht.count--
                        return
                }</span>
        }
}

func (ht *HashTable) Size() int <span class="cov8" title="1">{
        return ht.count
}</span>

func (ht *HashTable) Items() []struct{ Key, Value int } <span class="cov8" title="1">{
        items := make([]struct{ Key, Value int }, 0, ht.count)
        
        for i := 0; i &lt; ht.capacity; i++ </span><span class="cov8" title="1">{
                if ht.states[i] == Filled </span><span class="cov8" title="1">{
                        items = append(items, struct{ Key, Value int }{
                                Key:   ht.keys[i],
                                Value: ht.values[i],
                        })
                }</span>
        }
        
        <span class="cov8" title="1">return items</span>
}

func (ht *HashTable) SerializeBinary(w io.Writer) error <span class="cov8" title="1">{
        items := ht.Items()
        length := uint32(len(items))
        
        if err := binary.Write(w, binary.LittleEndian, length); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        
        <span class="cov8" title="1">for _, item := range items </span><span class="cov8" title="1">{
                if err := binary.Write(w, binary.LittleEndian, int32(item.Key)); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if err := binary.Write(w, binary.LittleEndian, int32(item.Value)); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        
        <span class="cov8" title="1">return nil</span>
}

func (ht *HashTable) DeserializeBinary(r io.Reader) error <span class="cov8" title="1">{
        var length uint32
        if err := binary.Read(r, binary.LittleEndian, &amp;length); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        
        <span class="cov8" title="1">ht.rehash(nextPow2(int(length)*2 + 8))
        
        for i := uint32(0); i &lt; length; i++ </span><span class="cov8" title="1">{
                var key, value int32
                if err := binary.Read(r, binary.LittleEndian, &amp;key); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if err := binary.Read(r, binary.LittleEndian, &amp;value); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                
                <span class="cov8" title="1">ht.Insert(int(key), int(value))</span>
        }
        
        <span class="cov8" title="1">return nil</span>
}

func (ht *HashTable) SerializeText(w io.Writer) error <span class="cov8" title="1">{
        items := ht.Items()
        
        if _, err := fmt.Fprintf(w, "%d\n", len(items)); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        
        <span class="cov8" title="1">for _, item := range items </span><span class="cov8" title="1">{
                if _, err := fmt.Fprintf(w, "%d %d\n", item.Key, item.Value); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        
        <span class="cov8" title="1">return nil</span>
}

func (ht *HashTable) DeserializeText(r io.Reader) error <span class="cov8" title="1">{
        var length int
        if _, err := fmt.Fscanf(r, "%d\n", &amp;length); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        
        <span class="cov8" title="1">ht.rehash(nextPow2(length*2 + 8))
        
        for i := 0; i &lt; length; i++ </span><span class="cov8" title="1">{
                var key, value int
                if _, err := fmt.Fscanf(r, "%d %d\n", &amp;key, &amp;value); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                
                <span class="cov8" title="1">ht.Insert(key, value)</span>
        }
        
        <span class="cov8" title="1">return nil</span>
}

type CuckooHashTable struct {
        keys1   []int
        vals1   []int
        used1   []bool
        
        keys2   []int
        vals2   []int
        used2   []bool
        
        capacity int
        count    int
}

func NewCuckooHashTable(capacity ...int) *CuckooHashTable <span class="cov8" title="1">{
        cap := 8
        if len(capacity) &gt; 0 &amp;&amp; capacity[0] &gt; 0 </span><span class="cov8" title="1">{
                cap = capacity[0]
        }</span>
        
        <span class="cov8" title="1">capacityInt := 1
        for capacityInt &lt; cap </span><span class="cov8" title="1">{
                capacityInt &lt;&lt;= 1
        }</span>
        <span class="cov8" title="1">if capacityInt &lt; 2 </span><span class="cov0" title="0">{
                capacityInt = 2
        }</span>
        
        <span class="cov8" title="1">cht := &amp;CuckooHashTable{
                capacity: capacityInt,
        }
        
        cht.keys1 = make([]int, cht.capacity)
        cht.vals1 = make([]int, cht.capacity)
        cht.used1 = make([]bool, cht.capacity)
        
        cht.keys2 = make([]int, cht.capacity)
        cht.vals2 = make([]int, cht.capacity)
        cht.used2 = make([]bool, cht.capacity)
        
        return cht</span>
}

func (cht *CuckooHashTable) hash1(key int) int <span class="cov8" title="1">{
        x := uint32(key)
        x *= 2654435761
        return int(x &amp; uint32(cht.capacity-1))
}</span>

func (cht *CuckooHashTable) hash2(key int) int <span class="cov8" title="1">{
        x := uint32(key)
        x ^= x &gt;&gt; 16
        x *= 2246822519
        x ^= x &gt;&gt; 13
        return int(x &amp; uint32(cht.capacity-1))
}</span>

func (cht *CuckooHashTable) rehash(newCapacity int) <span class="cov8" title="1">{
        current := cht.Items()
        
        cht.capacity = 1
        for cht.capacity &lt; newCapacity </span><span class="cov8" title="1">{
                cht.capacity &lt;&lt;= 1
        }</span>
        <span class="cov8" title="1">if cht.capacity &lt; 2 </span><span class="cov0" title="0">{
                cht.capacity = 2
        }</span>
        
        <span class="cov8" title="1">cht.keys1 = make([]int, cht.capacity)
        cht.vals1 = make([]int, cht.capacity)
        cht.used1 = make([]bool, cht.capacity)
        
        cht.keys2 = make([]int, cht.capacity)
        cht.vals2 = make([]int, cht.capacity)
        cht.used2 = make([]bool, cht.capacity)
        
        cht.count = 0
        
        for _, item := range current </span><span class="cov8" title="1">{
                cht.Insert(item.Key, item.Value)
        }</span>
}

func (cht *CuckooHashTable) Contains(key int) bool <span class="cov8" title="1">{
        return cht.Get(key) != -1
}</span>

func (cht *CuckooHashTable) Get(key int) int <span class="cov8" title="1">{
        i1 := cht.hash1(key)
        if cht.used1[i1] &amp;&amp; cht.keys1[i1] == key </span><span class="cov8" title="1">{
                return cht.vals1[i1]
        }</span>
        
        <span class="cov8" title="1">i2 := cht.hash2(key)
        if cht.used2[i2] &amp;&amp; cht.keys2[i2] == key </span><span class="cov0" title="0">{
                return cht.vals2[i2]
        }</span>
        
        <span class="cov8" title="1">return -1</span>
}

func (cht *CuckooHashTable) Insert(key, value int) <span class="cov8" title="1">{
        if cht.Contains(key) </span><span class="cov8" title="1">{
                i1 := cht.hash1(key)
                if cht.used1[i1] &amp;&amp; cht.keys1[i1] == key </span><span class="cov8" title="1">{
                        cht.vals1[i1] = value
                        return
                }</span>
                
                <span class="cov0" title="0">i2 := cht.hash2(key)
                if cht.used2[i2] &amp;&amp; cht.keys2[i2] == key </span><span class="cov0" title="0">{
                        cht.vals2[i2] = value
                        return
                }</span>
        }
        
        <span class="cov8" title="1">if float64(cht.count+1)/float64(cht.capacity) &gt; 0.45 </span><span class="cov8" title="1">{
                cht.rehash(cht.capacity * 2)
        }</span>
        
        <span class="cov8" title="1">curKey := key
        curVal := value
        
        const maxKicks = 32
        for kick := 0; kick &lt; maxKicks; kick++ </span><span class="cov8" title="1">{
                i1 := cht.hash1(curKey)
                if !cht.used1[i1] </span><span class="cov8" title="1">{
                        cht.used1[i1] = true
                        cht.keys1[i1] = curKey
                        cht.vals1[i1] = curVal
                        cht.count++
                        return
                }</span>
                
                <span class="cov0" title="0">curKey, cht.keys1[i1] = cht.keys1[i1], curKey
                curVal, cht.vals1[i1] = cht.vals1[i1], curVal
                
                i2 := cht.hash2(curKey)
                if !cht.used2[i2] </span><span class="cov0" title="0">{
                        cht.used2[i2] = true
                        cht.keys2[i2] = curKey
                        cht.vals2[i2] = curVal
                        cht.count++
                        return
                }</span>
                
                <span class="cov0" title="0">curKey, cht.keys2[i2] = cht.keys2[i2], curKey
                curVal, cht.vals2[i2] = cht.vals2[i2], curVal</span>
        }
        
        <span class="cov0" title="0">cht.rehash(cht.capacity * 2)
        cht.Insert(curKey, curVal)</span>
}

func (cht *CuckooHashTable) Remove(key int) <span class="cov8" title="1">{
        i1 := cht.hash1(key)
        if cht.used1[i1] &amp;&amp; cht.keys1[i1] == key </span><span class="cov8" title="1">{
                cht.used1[i1] = false
                cht.count--
                return
        }</span>
        
        <span class="cov8" title="1">i2 := cht.hash2(key)
        if cht.used2[i2] &amp;&amp; cht.keys2[i2] == key </span><span class="cov0" title="0">{
                cht.used2[i2] = false
                cht.count--
                return
        }</span>
}

func (cht *CuckooHashTable) Size() int <span class="cov8" title="1">{
        return cht.count
}</span>

func (cht *CuckooHashTable) Items() []struct{ Key, Value int } <span class="cov8" title="1">{
        items := make([]struct{ Key, Value int }, 0, cht.count)
        
        for i := 0; i &lt; cht.capacity; i++ </span><span class="cov8" title="1">{
                if cht.used1[i] </span><span class="cov8" title="1">{
                        items = append(items, struct{ Key, Value int }{
                                Key:   cht.keys1[i],
                                Value: cht.vals1[i],
                        })
                }</span>
        }
        
        <span class="cov8" title="1">for i := 0; i &lt; cht.capacity; i++ </span><span class="cov8" title="1">{
                if cht.used2[i] </span><span class="cov0" title="0">{
                        items = append(items, struct{ Key, Value int }{
                                Key:   cht.keys2[i],
                                Value: cht.vals2[i],
                        })
                }</span>
        }
        
        <span class="cov8" title="1">return items</span>
}

func (cht *CuckooHashTable) SerializeBinary(w io.Writer) error <span class="cov8" title="1">{
        items := cht.Items()
        length := uint32(len(items))
        
        if err := binary.Write(w, binary.LittleEndian, length); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        
        <span class="cov8" title="1">for _, item := range items </span><span class="cov8" title="1">{
                if err := binary.Write(w, binary.LittleEndian, int32(item.Key)); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if err := binary.Write(w, binary.LittleEndian, int32(item.Value)); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        
        <span class="cov8" title="1">return nil</span>
}

func (cht *CuckooHashTable) DeserializeBinary(r io.Reader) error <span class="cov8" title="1">{
        var length uint32
        if err := binary.Read(r, binary.LittleEndian, &amp;length); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        
        <span class="cov8" title="1">cht.rehash(int(length)*4 + 8)
        
        for i := uint32(0); i &lt; length; i++ </span><span class="cov8" title="1">{
                var key, value int32
                if err := binary.Read(r, binary.LittleEndian, &amp;key); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if err := binary.Read(r, binary.LittleEndian, &amp;value); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                
                <span class="cov8" title="1">cht.Insert(int(key), int(value))</span>
        }
        
        <span class="cov8" title="1">return nil</span>
}

func (cht *CuckooHashTable) SerializeText(w io.Writer) error <span class="cov8" title="1">{
        items := cht.Items()
        
        if _, err := fmt.Fprintf(w, "%d\n", len(items)); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        
        <span class="cov8" title="1">for _, item := range items </span><span class="cov8" title="1">{
                if _, err := fmt.Fprintf(w, "%d %d\n", item.Key, item.Value); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        
        <span class="cov8" title="1">return nil</span>
}

func (cht *CuckooHashTable) DeserializeText(r io.Reader) error <span class="cov8" title="1">{
        var length int
        if _, err := fmt.Fscanf(r, "%d\n", &amp;length); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        
        <span class="cov8" title="1">cht.rehash(length*4 + 8)
        
        for i := 0; i &lt; length; i++ </span><span class="cov8" title="1">{
                var key, value int
                if _, err := fmt.Fscanf(r, "%d %d\n", &amp;key, &amp;value); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                
                <span class="cov8" title="1">cht.Insert(key, value)</span>
        }
        
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package datastructures

import (
        "encoding/binary"
        "fmt"
        "io"
        "strings"
)

type queueNode struct {
        data string
        next *queueNode
}

type Queue struct {
        Name string
        head *queueNode
        tail *queueNode
}

func NewQueue(name string) *Queue <span class="cov8" title="1">{
        return &amp;Queue{Name: name}
}</span>

func (q *Queue) clear() <span class="cov8" title="1">{
        q.head = nil
        q.tail = nil
}</span>

func (q *Queue) Push(data string) <span class="cov8" title="1">{
        node := &amp;queueNode{data: data}
        if q.tail == nil </span><span class="cov8" title="1">{
                q.head = node
                q.tail = node
                return
        }</span>
        <span class="cov8" title="1">q.tail.next = node
        q.tail = node</span>
}

func (q *Queue) Pop() string <span class="cov8" title="1">{
        if q.head == nil </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">data := q.head.data
        q.head = q.head.next
        if q.head == nil </span><span class="cov8" title="1">{
                q.tail = nil
        }</span>
        <span class="cov8" title="1">return data</span>
}

func (q *Queue) Peek() string <span class="cov8" title="1">{
        if q.head == nil </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">return q.head.data</span>
}

func (q *Queue) IsEmpty() bool <span class="cov8" title="1">{
        return q.head == nil
}</span>

func (q *Queue) Read() string <span class="cov8" title="1">{
        var values []string
        current := q.head
        for current != nil </span><span class="cov8" title="1">{
                values = append(values, current.data)
                current = current.next
        }</span>
        <span class="cov8" title="1">return strings.Join(values, " ")</span>
}

func (q *Queue) SerializeBinary(w io.Writer) error <span class="cov8" title="1">{
        var values []string
        current := q.head
        for current != nil </span><span class="cov8" title="1">{
                values = append(values, current.data)
                current = current.next
        }</span>
        
        <span class="cov8" title="1">length := uint32(len(values))
        if err := binary.Write(w, binary.LittleEndian, length); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        
        <span class="cov8" title="1">for _, v := range values </span><span class="cov8" title="1">{
                strLen := uint32(len(v))
                if err := binary.Write(w, binary.LittleEndian, strLen); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if _, err := w.Write([]byte(v)); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (q *Queue) DeserializeBinary(r io.Reader) error <span class="cov8" title="1">{
        q.clear()
        
        var length uint32
        if err := binary.Read(r, binary.LittleEndian, &amp;length); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        
        <span class="cov8" title="1">for i := uint32(0); i &lt; length; i++ </span><span class="cov8" title="1">{
                var strLen uint32
                if err := binary.Read(r, binary.LittleEndian, &amp;strLen); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                
                <span class="cov8" title="1">buf := make([]byte, strLen)
                if _, err := io.ReadFull(r, buf); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">q.Push(string(buf))</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (q *Queue) SerializeText(w io.Writer) error <span class="cov8" title="1">{
        var values []string
        current := q.head
        for current != nil </span><span class="cov8" title="1">{
                values = append(values, current.data)
                current = current.next
        }</span>
        
        <span class="cov8" title="1">if _, err := fmt.Fprintf(w, "%d\n", len(values)); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        
        <span class="cov8" title="1">for _, v := range values </span><span class="cov8" title="1">{
                if _, err := fmt.Fprintf(w, "%s\n", v); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (q *Queue) DeserializeText(r io.Reader) error <span class="cov8" title="1">{
        q.clear()
        
        var length int
        if _, err := fmt.Fscanf(r, "%d\n", &amp;length); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        
        <span class="cov8" title="1">for i := 0; i &lt; length; i++ </span><span class="cov8" title="1">{
                var s string
                if _, err := fmt.Fscanf(r, "%s\n", &amp;s); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">q.Push(s)</span>
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package datastructures

import (
        "encoding/binary"
        "fmt"
        "io"
        "strings"
)

type stackNode struct {
        data string
        next *stackNode
}

type Stack struct {
        Name string
        top  *stackNode
}

func NewStack(name string) *Stack <span class="cov8" title="1">{
        return &amp;Stack{Name: name}
}</span>

func (s *Stack) clear() <span class="cov8" title="1">{
        s.top = nil
}</span>

func (s *Stack) Push(data string) <span class="cov8" title="1">{
        node := &amp;stackNode{data: data}
        node.next = s.top
        s.top = node
}</span>

func (s *Stack) Pop() string <span class="cov8" title="1">{
        if s.top == nil </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">data := s.top.data
        s.top = s.top.next
        return data</span>
}

func (s *Stack) Peek() string <span class="cov8" title="1">{
        if s.top == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov8" title="1">return s.top.data</span>
}

func (s *Stack) IsEmpty() bool <span class="cov8" title="1">{
        return s.top == nil
}</span>

func (s *Stack) Read() string <span class="cov8" title="1">{
        var values []string
        current := s.top
        for current != nil </span><span class="cov8" title="1">{
                values = append(values, current.data)
                current = current.next
        }</span>
        <span class="cov8" title="1">return strings.Join(values, " ")</span>
}

func (s *Stack) SerializeBinary(w io.Writer) error <span class="cov8" title="1">{
        var values []string
        current := s.top
        for current != nil </span><span class="cov8" title="1">{
                values = append(values, current.data)
                current = current.next
        }</span>
        
        <span class="cov8" title="1">length := uint32(len(values))
        if err := binary.Write(w, binary.LittleEndian, length); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        
        <span class="cov8" title="1">for _, v := range values </span><span class="cov8" title="1">{
                strLen := uint32(len(v))
                if err := binary.Write(w, binary.LittleEndian, strLen); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if _, err := w.Write([]byte(v)); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (s *Stack) DeserializeBinary(r io.Reader) error <span class="cov8" title="1">{
        s.clear()
        
        var length uint32
        if err := binary.Read(r, binary.LittleEndian, &amp;length); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        
        <span class="cov8" title="1">temp := make([]string, length)
        for i := 0; i &lt; int(length); i++ </span><span class="cov8" title="1">{
                var strLen uint32
                if err := binary.Read(r, binary.LittleEndian, &amp;strLen); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                
                <span class="cov8" title="1">buf := make([]byte, strLen)
                if _, err := io.ReadFull(r, buf); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">temp[i] = string(buf)</span>
        }
        
        <span class="cov8" title="1">for i := len(temp) - 1; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                s.Push(temp[i])
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (s *Stack) SerializeText(w io.Writer) error <span class="cov8" title="1">{
        var values []string
        current := s.top
        for current != nil </span><span class="cov8" title="1">{
                values = append(values, current.data)
                current = current.next
        }</span>
        
        <span class="cov8" title="1">if _, err := fmt.Fprintf(w, "%d\n", len(values)); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        
        <span class="cov8" title="1">for _, v := range values </span><span class="cov8" title="1">{
                if _, err := fmt.Fprintf(w, "%s\n", v); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (s *Stack) DeserializeText(r io.Reader) error <span class="cov8" title="1">{
        s.clear()
        
        var length int
        if _, err := fmt.Fscanf(r, "%d\n", &amp;length); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        
        <span class="cov8" title="1">temp := make([]string, length)
        for i := 0; i &lt; length; i++ </span><span class="cov8" title="1">{
                var data string
                if _, err := fmt.Fscanf(r, "%s\n", &amp;data); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">temp[i] = data</span>
        }
        
        <span class="cov8" title="1">for i := len(temp) - 1; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                s.Push(temp[i])
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package datastructures

import (
        "encoding/binary"
        "fmt"
        "io"
        "strconv"
        "strings"
)

type treeNode struct {
        value int
        left  *treeNode
        right *treeNode
}

type Tree struct {
        Name string
        root *treeNode
}

func NewTree(name string) *Tree <span class="cov8" title="1">{
        return &amp;Tree{Name: name}
}</span>

func (t *Tree) destroy(node *treeNode) <span class="cov8" title="1">{
        if node == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov0" title="0">t.destroy(node.left)
        t.destroy(node.right)</span>
}

func (t *Tree) insertBST(node **treeNode, value int) <span class="cov8" title="1">{
        if *node == nil </span><span class="cov8" title="1">{
                *node = &amp;treeNode{value: value}
                return
        }</span>
        
        <span class="cov8" title="1">if value &lt; (*node).value </span><span class="cov8" title="1">{
                t.insertBST(&amp;(*node).left, value)
        }</span> else<span class="cov8" title="1"> if value &gt; (*node).value </span><span class="cov8" title="1">{
                t.insertBST(&amp;(*node).right, value)
        }</span>
}

func (t *Tree) findBST(node *treeNode, value int) bool <span class="cov8" title="1">{
        if node == nil </span><span class="cov8" title="1">{
                return false
        }</span>
        
        <span class="cov8" title="1">if value == node.value </span><span class="cov8" title="1">{
                return true
        }</span>
        
        <span class="cov8" title="1">if value &lt; node.value </span><span class="cov8" title="1">{
                return t.findBST(node.left, value)
        }</span>
        
        <span class="cov8" title="1">return t.findBST(node.right, value)</span>
}

func (t *Tree) preorder(node *treeNode, out *strings.Builder) <span class="cov8" title="1">{
        if node == nil </span><span class="cov8" title="1">{
                return
        }</span>
        
        <span class="cov8" title="1">if out.Len() &gt; 0 </span><span class="cov8" title="1">{
                out.WriteByte(' ')
        }</span>
        <span class="cov8" title="1">out.WriteString(strconv.Itoa(node.value))
        
        t.preorder(node.left, out)
        t.preorder(node.right, out)</span>
}

func (t *Tree) isFullImpl(node *treeNode) bool <span class="cov8" title="1">{
        if node == nil </span><span class="cov8" title="1">{
                return true
        }</span>
        
        <span class="cov8" title="1">if node.left == nil &amp;&amp; node.right == nil </span><span class="cov8" title="1">{
                return true
        }</span>
        
        <span class="cov8" title="1">if node.left != nil &amp;&amp; node.right != nil </span><span class="cov8" title="1">{
                return t.isFullImpl(node.left) &amp;&amp; t.isFullImpl(node.right)
        }</span>
        
        <span class="cov8" title="1">return false</span>
}

func (t *Tree) Insert(value int) <span class="cov8" title="1">{
        t.insertBST(&amp;t.root, value)
}</span>

func (t *Tree) Find(value int) bool <span class="cov8" title="1">{
        return t.findBST(t.root, value)
}</span>

func (t *Tree) Read() string <span class="cov8" title="1">{
        var builder strings.Builder
        t.preorder(t.root, &amp;builder)
        return builder.String()
}</span>

func (t *Tree) IsFull() bool <span class="cov8" title="1">{
        return t.isFullImpl(t.root)
}</span>

func (t *Tree) serializeBinNode(w io.Writer, node *treeNode) error <span class="cov8" title="1">{
        present := uint8(0)
        if node != nil </span><span class="cov8" title="1">{
                present = 1
        }</span>
        
        <span class="cov8" title="1">if err := binary.Write(w, binary.LittleEndian, present); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        
        <span class="cov8" title="1">if node == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        
        <span class="cov8" title="1">if err := binary.Write(w, binary.LittleEndian, int32(node.value)); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        
        <span class="cov8" title="1">if err := t.serializeBinNode(w, node.left); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        
        <span class="cov8" title="1">if err := t.serializeBinNode(w, node.right); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        
        <span class="cov8" title="1">return nil</span>
}

func (t *Tree) deserializeBinNode(r io.Reader) (*treeNode, error) <span class="cov8" title="1">{
        var present uint8
        if err := binary.Read(r, binary.LittleEndian, &amp;present); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        
        <span class="cov8" title="1">if present == 0 </span><span class="cov8" title="1">{
                return nil, nil
        }</span>
        
        <span class="cov8" title="1">var value int32
        if err := binary.Read(r, binary.LittleEndian, &amp;value); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        
        <span class="cov8" title="1">node := &amp;treeNode{value: int(value)}
        
        left, err := t.deserializeBinNode(r)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">node.left = left
        
        right, err := t.deserializeBinNode(r)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">node.right = right
        
        return node, nil</span>
}

func (t *Tree) SerializeBinary(w io.Writer) error <span class="cov8" title="1">{
        return t.serializeBinNode(w, t.root)
}</span>

func (t *Tree) DeserializeBinary(r io.Reader) error <span class="cov8" title="1">{
        t.destroy(t.root)
        
        node, err := t.deserializeBinNode(r)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        
        <span class="cov8" title="1">t.root = node
        return nil</span>
}

func (t *Tree) serializeTextNode(w io.Writer, node *treeNode) error <span class="cov8" title="1">{
        if node == nil </span><span class="cov8" title="1">{
                _, err := fmt.Fprint(w, "# ")
                return err
        }</span>
        
        <span class="cov8" title="1">_, err := fmt.Fprintf(w, "%d ", node.value)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        
        <span class="cov8" title="1">if err := t.serializeTextNode(w, node.left); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        
        <span class="cov8" title="1">if err := t.serializeTextNode(w, node.right); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        
        <span class="cov8" title="1">return nil</span>
}

func (t *Tree) deserializeTextNode(r io.Reader) (*treeNode, error) <span class="cov8" title="1">{
        var tok string
        _, err := fmt.Fscan(r, &amp;tok)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        
        <span class="cov8" title="1">if tok == "#" </span><span class="cov8" title="1">{
                return nil, nil
        }</span>
        
        <span class="cov8" title="1">value, err := strconv.Atoi(tok)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        
        <span class="cov8" title="1">node := &amp;treeNode{value: value}
        
        left, err := t.deserializeTextNode(r)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">node.left = left
        
        right, err := t.deserializeTextNode(r)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">node.right = right
        
        return node, nil</span>
}

func (t *Tree) SerializeText(w io.Writer) error <span class="cov8" title="1">{
        return t.serializeTextNode(w, t.root)
}</span>

func (t *Tree) DeserializeText(r io.Reader) error <span class="cov8" title="1">{
        t.destroy(t.root)
        
        node, err := t.deserializeTextNode(r)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        
        <span class="cov8" title="1">t.root = node
        return nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
